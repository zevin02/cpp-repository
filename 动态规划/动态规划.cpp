#include<iostream>
using namespace std;
//动态规划
//考虑
//1.状态定义
//2.状态转义方程（递推方程）（一步一步的变化达到当前的状态）
//3.初始化状态
//4.结果的返回

//实用场景
//最大值，最小值，可不可行，是不是，方案个数


//斐波那契
//状态：定义成第i项的值
//求第n项的结果
//状态转义方程 f(i)=f(i-1)+f(i-2)
//初始状态f（0）=0，f（1）=1

class Solutionfib {
public:
    int fib(int n) {
        int* f = new int[n + 2];
        //初始状态
        f[0] = 0;
        f[1] = 1;
        long long mod = 1e9 + 7;
        int i = 2;
        for (i = 2; i <= n; i++)
        {
            f[i] = (f[i - 1] + f[i - 2]) % mod;//状态转义方程
        }
        return f[n];//返回结果

    }
};


//字符串分割
//给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

//注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
//输入: s = "leetcode", wordDict = ["leet", "code"]
//输出 : true
//解释 : 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
//
//因为是判断可不可以，所以可以用动态规划求解

//全部状态都找出来，进行匹配是否有字串可以找得到
//
//问题：字符串可不可以被分割--》抽象出来状态
//状态的定义：某一个字串可不可以被分割，通过某一字串能不能被找得到
//f（i）=========》前i个字符是否可以被分割
//f（n）代表字符串的所有字符能不能被分割
//状态转义方程：j<i&&f[j]&&[j+1,i]

//f（4）表示前4个字符可不可以被分割，是可以的
//初始状态：整体能不能找得到f（0）：一般为真，辅助的一个状态
